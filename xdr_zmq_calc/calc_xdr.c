/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "calc.h"

bool_t
xdr_AddWork(xdrs, objp)
	XDR *xdrs;
	AddWork *objp;
{
	int32_t *buf;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = (int32_t *)XDR_INLINE(xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->num1))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->num2))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->num3))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->num4))
				return (FALSE);
		} else {
			IXDR_PUT_LONG(buf, objp->num1);
			IXDR_PUT_LONG(buf, objp->num2);
			IXDR_PUT_LONG(buf, objp->num3);
			IXDR_PUT_LONG(buf, objp->num4);
		}
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = (int32_t *)XDR_INLINE(xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->num1))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->num2))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->num3))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->num4))
				return (FALSE);
		} else {
			objp->num1 = IXDR_GET_LONG(buf);
			objp->num2 = IXDR_GET_LONG(buf);
			objp->num3 = IXDR_GET_LONG(buf);
			objp->num4 = IXDR_GET_LONG(buf);
		}
	} else {
		if (!xdr_int(xdrs, &objp->num1))
			return (FALSE);
		if (!xdr_int(xdrs, &objp->num2))
			return (FALSE);
		if (!xdr_int(xdrs, &objp->num3))
			return (FALSE);
		if (!xdr_int(xdrs, &objp->num4))
			return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_AddResult(xdrs, objp)
	XDR *xdrs;
	AddResult *objp;
{

	if (!xdr_int(xdrs, &objp->num))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_SubWork(xdrs, objp)
	XDR *xdrs;
	SubWork *objp;
{

	if (!xdr_int(xdrs, &objp->num1))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->num2))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_SubResult(xdrs, objp)
	XDR *xdrs;
	SubResult *objp;
{

	if (!xdr_int(xdrs, &objp->num))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_MulWork(xdrs, objp)
	XDR *xdrs;
	MulWork *objp;
{

	if (!xdr_int(xdrs, &objp->num1))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->num2))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->num3))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_MulResult(xdrs, objp)
	XDR *xdrs;
	MulResult *objp;
{

	if (!xdr_int(xdrs, &objp->num))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_DivWork(xdrs, objp)
	XDR *xdrs;
	DivWork *objp;
{

	if (!xdr_int(xdrs, &objp->num1))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->num2))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_DivResult(xdrs, objp)
	XDR *xdrs;
	DivResult *objp;
{

	if (!xdr_int(xdrs, &objp->num))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_FacWork(xdrs, objp)
	XDR *xdrs;
	FacWork *objp;
{

	if (!xdr_int(xdrs, &objp->num1))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_FacResult(xdrs, objp)
	XDR *xdrs;
	FacResult *objp;
{

	if (!xdr_int(xdrs, &objp->num))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->err))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_calc_req(xdrs, objp)
	XDR *xdrs;
	calc_req *objp;
{

	if (!xdr_int(xdrs, &objp->op))
		return (FALSE);
	switch (objp->op) {
	case ADD:
		if (!xdr_AddWork(xdrs, &objp->calc_req_u.add_request))
			return (FALSE);
		break;
	case SUBTRACT:
		if (!xdr_SubWork(xdrs, &objp->calc_req_u.sub_request))
			return (FALSE);
		break;
	case MULTIPLY:
		if (!xdr_MulWork(xdrs, &objp->calc_req_u.mul_request))
			return (FALSE);
		break;
	case DIVIDE:
		if (!xdr_DivWork(xdrs, &objp->calc_req_u.div_request))
			return (FALSE);
		break;
	case FACTORIAL:
		if (!xdr_FacWork(xdrs, &objp->calc_req_u.fac_request))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_calc_res(xdrs, objp)
	XDR *xdrs;
	calc_res *objp;
{

	if (!xdr_int(xdrs, &objp->op))
		return (FALSE);
	switch (objp->op) {
	case ADD:
		if (!xdr_AddResult(xdrs, &objp->calc_res_u.add_result))
			return (FALSE);
		break;
	case SUBTRACT:
		if (!xdr_SubResult(xdrs, &objp->calc_res_u.sub_result))
			return (FALSE);
		break;
	case MULTIPLY:
		if (!xdr_MulResult(xdrs, &objp->calc_res_u.mul_result))
			return (FALSE);
		break;
	case DIVIDE:
		if (!xdr_DivResult(xdrs, &objp->calc_res_u.div_result))
			return (FALSE);
		break;
	case FACTORIAL:
		if (!xdr_FacWork(xdrs, &objp->calc_res_u.fac_result))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}
